## 리눅스 tutorial
### 0. 리눅스 환경 구축하기
- 아래의 내용은 생활코딩 강의를 바탕으로 정리한 것.
- <a href="https://opentutorials.org/course/2598">생활코딩 강좌</a>
- 리눅스를 직접 설치하는 것은 번거롭다. 따라서 웹 서비스를 이용해 즉각적으로 리눅스를 사용할 수 있도록 환경을 구축한다.
- 방법
    1. CodeOnWeb에서 실습환경을 구축한다. 좌측의 실행환경에서 Linux shell을 선택하면 linux사용환경이 구축된다.
    2. C9.io에서 linux환경을 구축한다.
    3. 가상머신을 이용한다.
### 1. 명령어(CLI환경 : command line interface, 명령어로 조작하는 환경)
- 명령어는 현재 디렉토리를 대상으로 하여 실행된다.
- 명령어(parameter를 이용해 해당 명령어의 실행 방식을 다룰 수 있다.)
    - ls : 현재 목록을 확인한다.(아래는 parameter)
        - -l : 현재 디렉토리의 파일 및 하위 디렉토리를 자세히 보여준다.
            - 제일 좌측의 d는 directory를 의미하며, -는 file을 의미한다.
            - 중간의 4096과 같은 숫자는 용량을 의미한다.
        - -a : .으로 시작하는 파일도 모두 보여준다.(.으로 시작하는 것은 숨김파일)
        - -S : file size에 따라 정렬한다.
    - pwd : 현재 위치를 확인한다.
    - mkdir directory_name : 지정한 name의 directory를 만든다.
    - touch 파일명 : 비어있는 해당 name의 file을 생성한다.
    - rm : 파일을 삭제한다.
    - cp : 파일을 복사한다.
    - mv : 파일을 이동시킨다., 파일 이름을 변경시킬 때도 이를 사용
    - cat file_name : 파일 이름을 출력
    - grep <정보> <파일명> : 특정 정보가 포함된 행을 찾는 명령
    - ps : 실행중인 process를 보여준다.
        - ps ax : 모든 프로세스를 볼 수 있다.(u까지 넣으면 자세하게 보여줌)
        - -o : 실행시 특정 칼럼만 출력시킬 수 있다.
    - head, tail : 앞의 뒷의 내용을 일부만 출력
    - !! : 직전에 사용한 명령어
    - history | awk '{a[$2]++}END{for(i in a){print a[i] " " i}}' | sort -rn | head -10 : 내가 쳤던 명령어 history를 빈도수에 따라 정렬해서 보여줌
- 명령어 사용법을 확인하는 방법
    - --help를 특정 명령어 뒤에 지정한다.
        - ex) `ls --help` : ls명령어의 manual을 확인가능
    - man
        - `man ls` 와 같이 사용한다.
        - 새로운 페이지로 들어가서 확인한다.
        - 방향키를 이용해 이동할 수 있으며, 특정 내용을 찾고 싶은 경우 명령환경에서 `/내용`를 사용한다.
        - n키를 이용해 찾는 내용의 다음내용으로 이동 가능, shift+n을 통해 이전 검색 내용으로 이동 가능
        - q를 사용해 나올 수 있다.
    - man과 help의 차이 : man은 전용페이지로 이동해 상세한 메뉴얼을 보이며, help는 간략하다.
    - ex) `mkdir --help`
        - `Usage: mkdir [OPTION]... DIRECTORY...` : 사용법을 의미하며, option을 줄 수 있고 그 뒤에 DIRECTORY를 지정하는 것.
        - OPTION은 바로 아래의 arguments들을 지정가능
            - 해당 예로 -p를 OPTION으로 주면, 필요시 부모 디렉토리를 생성한다.
            - `mkdir -p dir1/dir2/dir3/dir4` : 부모디렉토리로 계속 생성
            - OPTION은 -p처럼 축약형 혹은 --parents와 같이 full로 지정가능
- 필요한 명령어를 검색하여 찾기
    - google 검색엔진에서 검색한다.
         - ex) create directory in linux와 같이 검색해보면 된다.
    - <a href="https://maker.pro/linux/tutorial/basic-linux-commands-for-beginners">참조</a>
- sudo
    - sudo : super user do, 즉 super user가 하는 일이라는 것.
    - unix 계열의 운영체제는 다중 사용자 시스템이라는 특징을 가진다. 하나의 운영체제를 여럿이 사용해서 공동체가 형성된다.
    - 그래서, 파일의 권한을 지정하는 것이 중요하다.(permission)
    - 근데, 항상 슈퍼유저로써 권한을 가진 상태에서 명령을 실행하다 보면 매우 위험한 상황이 일어날 수 있다. 그래서 평시에는 일반유저로, 필요시에 sudo를 사용해 권한을 얻는것이다.
    - `apt-get install git` : 이를 실행해보면 permission이 denied된다. root유저가 아니기 때문
    - 이 때, `sudo apt-get install git`으로 하면 가능하다.
### 2. editor
- 파일 편집(nano editor)
    - `nano`를 입력하면 editor를 열 수 있다.
    - editor아래 쪽에는 ^G, ^O와 같이 있는데 ^는 ctrl을 의미한다.
    - 따라서, ctrl + O는 WriteOut이므로 누르면 fileName을 지정하라고 하는데 hello.html로 입력하고 enter를 누르면 `Wrote n lines`라고 나온다.
    - 그것은, 저장되었다는 것을 의미한다. ctrl+X를 누르고 나가서 ls로 확인가능
    - 다시 해당 파일을 수정하고 싶다면 `nano hello.html`로 하면 된다.
    - ctrl + k로 잘라내고 ctrl + u로 붙여넣을 수 있다.(capslock이 반드시 꺼져 있어야 한다. 켜있으면 shift도 눌러야함)
    - ctrl+shift(안눌러도 되는 경우도 있는 듯)+6으로 markset을 사용가능. markset을 이용해 block을 지정할 수 있고 그를 통해 특정 문구를 잘라내고 붙여넣을 수 있다.
    - ctrl+w로 검색할 수 있다.(c9환경에서는 ctrl+alt+shift를 누르고 명령을 수행하라.)
- vi editor
### 3. package manager
- package란 프로그램, app과 같은 것을 의미한다. package를 이용하여 컴퓨터의 다양한 처리를 한다.
- package manager는 app store와 같이 package를 다운로드받거나 관리할 수 있는 것이다.
- apt(패키지 매니저)
    - sudo apt-get update : apt라는 manager를 이용하여 다운받을 수 있는 목록을 최신상태로 update한다.
    - sudo apt-cache search name : name에 해당하는 다운로더블한 패키지를 확인 가능
        - top : window에 있는 작업관리자와 같은 것이다. 이를 좀 더 graphical하게 볼 수 있도록 htop설치
    - sudo apt-get : 설명서 나옴
    - sudo apt-get install htop : htop설치가능
    - sudo apt-get upgrade : 모든 package를 다 upgrade(특정 패키지만 업그레이드 하고 싶은 경우 이름을 주면 된다.)
    - sudo apt-get remove name : 특정 package 삭제
    - sudo apt-get dist-upgrade : 의존성 검사 후 업그레이드
    - sudo apt-get --reinstall install <package name> : 패키지 재설치
    - sudo apt-get --purge remove <package name> : 설정파일까지 모두 지움
    - sudo apt-get source <package name> : 패키지 소스코드 다운로드
    - sudo apt-get build-dep <package name> : 소스코드를 의존성 있게 빌드
    - sudo apt-cache show <package name> : 패키지 정보 보기
### 4. File download
- wget url : url을 통해서 파일을 다운로드받을 수 있다.
    - -O를 통해서 직접 이름을 지정할 수 있다.
    - wget --help를 이용해 manual을 확인하자
- git을 이용한 github url의 source를 받기
    - git clone url을 이용해 다운로드 받을 수 있다.
### 5. GUI vs CLI
- CLI를 사용하는 이유
    - GUI는 사용하기 편리하지만 computer의 resource를 매우 많이 잡아먹는다.
    - GUI는 순차적으로 진행되는 일을 자동화하기 어렵다.
- 순차적 실행?
    - mkdir why; cd why : why디렉토리를 만들고 거기로 이동한다.
    - 따라서, 이 명령어를 통해 거둘 수 있는 효과는 앞으로 필요한 process를 자동적으로 수행하고 최종 결과를 사용자에게 가져다준다는 것
    - 만약 매우 복잡하고 시간이 오래 걸릴 수 있는 명령어가 있는 경우 순차적으로 실행후 결과만 볼 수 있다.
- pipeline
    - 하나의 명령(프로그램, 프로세스)의 출력을 다른 명령(프로그램, 프로세스)의 입력으로 준다.
    - 예를 들어, grep을 이용해 특정 정보를 가진 행만을 화면에 보여주고 싶은 경우
    - `ls --help | grep sort` : ls의 manual 결과를 가지고 해당 내용에서 sort라는 정보를 가진 행만 출력해준다.
### 6. IO Redirection
- I : input, O : output 으로 입출력을 의미하며, redirection은 방향을 바꾼다는 의미다.
    - input과 output은 standard한 방식이 존재한다.
    - 표준 입력 및 출력이며, error의 경우에도 존재한다.
- process는 기본적으로 입력과 출력을 갖는다.
    - 예를 들어, `ls -al` 이라면 -al은 입력값이다.(command line arguments)
    - 또한 해당 결과를 화면에 보여주는데, 이것이 standard output
    - 이 standard output의 방향을 바꾸어서 파일로 redirection이 가능하다.
- `>` : 이 기호를 통해서 출력할 결과를 특정 파일에 저장할 수 있다.
    - `ls -l > result.txt` : cat result.txt를 통해 내용이 저장된 것을 확인가능
    - 해당 기호는 기본적으로 앞에 1이 생략되어 있기 때문에 standard output을 저장하는 방식이다.
    - 만약 standard error를 저장하고 싶다면 2로 지정해야 한다.
    - ex) rename2.txt를 삭제한 후 다시 삭제하는 경우
        - 에러가 발생한다.
        - 해당 내용을 단순히 `>` 를 이용해 다른 파일에 저장하려하면 저장되지 않는다.
        - 왜냐하면 그것은 standard error가 아닌 output을 저장하는 방식이기 때문
        - 따라서, `rm rename2.txt 2> error.log`로 해야 한다. 따라서 아래와 같이 쓴다.
        - `rm rename2.txt > result.txt 2> error.log`
    - `>>` 기호는 실행할 때마다 추가하는 것.
- Input
    - program arguments : control information
    - environment arguments : state information
    - standard input
        - standard input은 keyboard로 사용자가 입력한 내용을 의미한다.        
        - cat 명령어
            - 기존에는 파일의 내용을 보여줬다.
            - 단순히 cat만 쓰고 enter를 누르면 사용자가 keyboard로 input한 내용을 보여준다.
            - 따라서 표준 입력을 받을 수 있는 명령어 이므로 < 를 통해 파일명을 지정할 수 있다.
            - ex)만약, hello.txt에 hello라는 내용만 들어있다고 가정한다.
                - 해당 내용을 보기 위해서 cat hello.txt로 바로 볼 수도 있지만
                - cat < hello.txt로 내용을 볼 수 도 있다. 표준 입력!
        - head 
            - head -n1 linux.txt라고 하면 1줄만 출력한다.
                - 이 방식은 command line argument로 명령어의 인자로 준 것이다.
                - 만약? standard input으로 주고 싶다면??
            - head -n1 < linux.txt로 사용한다.
                - 즉, linux.txt의 내용을 standard input으로 redirection하여 head라는 process의 입력값이 된다.
                - 그렇다면, 위 내용을 결과로 저장하고 싶다면?
            - head -n1 < linux.txt > one.txt
                - 즉, 해당 결과를 one.txt에 저장할 수 있다.
- 지금까지 한 내용처럼 input과 output으로 넘기는 것을 stream이라고 한다. 
### 7. 쉘과 커널
- 쉘
    - 기능 : 사용자의 명령을 shell이 번역하여 kernel에 전달한다., 즉, 커널을 직접 제어할 수 없으므로 사람이 이해하기 쉬운 명령을 해석하여 커널에 전달한다.
    - 여러 가지 종류의 shell이 존재한다. ex) bash, zsh
    - zsh 라고 검색했을 때 안나오면 설치가 안된 것. `sudo apt-get install zsh`로 설치 가능
    - `echo $0`을 통해 현재 사용중인 shell을 알 수 있다.
        > shell은 어디에 위치하고 있을까? `ls /bin`을 해보면 알 수 있다.
        
        > /bin은 linux 운영체제에서 사용하는 기본프로그램이 위치하는 디렉토리이다!, 이전에 사용했던 rm, cat과 같은 명령어도 해당 위치에 파일로 존재한다는 것을 알 수 있다.

    - bash vs zsh
        - zsh는 cd 이후 tab을 누르면 가능한 디렉토리를 보여주는데, 숨김은 보여주지 않음.
        - zsh는 좀 더 편의성이 높다. /home/ubuntu로 이동시 /h/u하고 tab누르면 알아서 변형
        - 디렉토리 이동시 더욱 편의
    - shell script
        - shell에서 실행되는 명령들을 저장해놓을 수 있다.
        - 이를 통해 자동화된 업무를 수행할 수 있다.
        - 실제로 업무 프로세스 상에서는 복잡한 명령 구조를 통해 진행되는 경우가 많은데, 이를 항상 기억해두기보단 필요할 때 마다 저장된 내용을 꺼내서 쓰는 것이 이득일 것.
        - 예시(nano editor로 저장)
            - <pre><code>
                #!/bin/bash         --> #!를 인지하고 해당 내용이 bash로 해석되어야 한다는 것을 인지함
                if ! [ -d bak ]; then --> bak이 디렉토리이며 존재하지 않는다면
                        mkdir bak     --> 만든다.
                fi                    --> if 종료문
                
                cp *.log bak
            </code></pre>
        - 위 스크립트를 실행시에는 `./backup`과 같이 파일이름으로 실행할 수 있다. permission denied가 된다면 권한을 변경하면 된다.
            > `chmod +x backup` : 이를 통해 실행권한을 추가할 수 있다.

    * wild card
        - `*` 를 이용해 사용 만약 a.log, b.log, c.log가 있다고 가정했을 때, *.log라고 하면 확장자가 .log인 모든 파일을 의미(현재 디렉토리에서)
- kernel
    - 하드웨어를 제어하여 명령을 수행한다.
- 왜 커널과 쉘은 분리되어 있을까?? 찾아보자.
### 8. 디렉토리의 구조
- <a href="https://www.thegeekstuff.com/2010/09/linux-file-system-structure">참조</a>
- 각 디렉토리
    - / 
        - root directory, 최상위 디렉토리
    - /bin
        - binary의 줄임말이며 2진수라는 의미이다.
        - 실행가능한 프로그램을 컴퓨터에서는 binary라고도 부른다.
        - 이곳에는 사용자가 실행가능한 명령어 프로그램이 위치한다.
    - /sbin
        - System binaries를 의미한다.
        - 이 또한 바이너리 프로그램이 위치함.
        - system administrator가 사용하는 프로그램이 위치한다. 일반사용자가 이용하는 것은 /bin에 위치
    - /etc
        - 설정파일이다.
        - 대부분의 프로그램의 설정은 파일을 변경하는 곳.
        - 이미 설치된 프로그램, 운영체제의 설정을 건드릴 수 있음.
    - /dev
        - device files
    - /proc
        -  process information
    - /var
        - variable files로 용량이 바뀔 수 있다는 것.
        - 즉, 내용이 변경될 수 있는 파일들이 위치하고 있다.
    - /tmp
        - 임시파일이 저장됨. 종료 후 다시 켜면 다 삭제됨.
    - /home
        - 사용자들의 directory
        - home directory아래에 각 사용자들의 파일이 저장될 수 있도록 각 디렉토리가 존재할 수 있다.
        - 어디에 위치하건 나의 home directory로 이동해야할 경우가 많이 있다.
        - cd /home/ubuntu와 같이도 가능하지만, cd ~를 이용하면 현재 사용자의 home 디렉토리로 한번에 이동가능하다.\
    - /boot
    - /lib
        - /bin과 /sbin에 위치하는 프로그램이 공통으로 사용하는 라이브러리가 위치함.
    - /opt
        - Optional add-on Applications
        - 일반적으로 apt-get을 통해 패키지를 다운로드 받으면 특정 디렉토리에 위치하게 된다.
        - 이 것을 사용자 지정 디렉토리로 설정하고 싶을 때, 애매한 경우 Opt에 놓으면 된다.
    - /mnt
    - /media
    - /srv
    - /usr
        - 사용자 프로그램이 저장되는 디렉토리이며 내부에 아래와 같이 분화되어 있다.
        - /bin
        - /sbin
        - /lib
        - /local
        - 역사적인 맥락에 따라서, 기존에는 필요했던 부분이지만 지금은 거의 통합되어 잘 사용하지 않기도 함.
        - 지금은 home directory에 각 유저의 프로그램이 위치.
### 9. 프로세스
- 하드웨어 상식
    - 컴퓨터의 내부 구조
        - cpu : processor -> 프로그램 처리
        - ram : memory -> 필요 프로그램 적재
        - ssd/hdd : storage --> 가격이 싸며 용량이 큼, 속도는 느림
            - 이 속도로는 cpu의 고속처리 속도를 따라갈수가 없다.
            - 그래서 실행되는 프로그램은 읽어서 메모리에 적재시키고 해당 프로그램을 cpu에서 처리하는 것이다.
        - 위와 같은 기본적인 설계임. process는 ram에 적재되어 실행중인 프로그램을 의미한다.
        - 그리고 그 프로그램을 처리하는 것이 cpu, 즉 processor
- 프로세스 모니터링
    - ps
        - process 리스트를 보여줌
        - `ps aux`라고 하면 background의 모든 실행중인 프로그램을 보여준다.
        - PID : 각각의 프로세스의 식별자이다. 이를 통해 process를 kill가능
             - `sudo kill [pid]`
    - top
        - `sudo top`으로 가능
    - htop
        - top하고 같은데 좀 더 graphical함.
        - 실제 메모리 사용 : RES
        - 실행 시간 : Time+
        - command : 어떤 명령으로 실행되었는가
        - 물리적인 메모리의 크기 : MEM%
        - 위 쪽의 숫자는 cpu들을 의미하며 Mem은 메모리사용 정도임.
        - Load average는 평균 부하를 의미한다. 즉, cpu의 점유율과 관련. 각각 1, 5, 15분간 cpu 점유율 평균치
### 10. 파일을 찾는 방법
- 파일의 용도
    - 데이터 보관, 실행파일(명령을 보관)
- 찾기
    - locate
        - 실행 안되면 `sudo updatedb`를 해주자. 명령어의 위치를 디비에 저장하는 방식이기 때문에 update하지 않으면 찾지 못한다.
        - database를 뒤져서 파일을 찾는다.
        - ex) `locate *.log` : .log 확장자인 모든 파일을 찾는다.
        - locate가 사용하는 데이터베이스를 mlocate라고 부르며 `sudo updatedb`를 수행하면 mlocate의 현재 존재하는 파일들의 정보를 update할 수 있다.(일반적으로 정기적으로 수행되는 명령)
    - find
        - <a href="http://webdir.tistory.com/155">참조</a>
        - 사용법 : find [검색대상위치] [옵션] [수행할작업]
    - whereis
        - `whereis ls` : ls파일이 위치하는 곳을 알려줌.(복수)
            - ls가 존재하는 파일, manual이 존재하는 위치를 알려줌
            - ls가 위치하는 것은 /bin/ls인데 왜 ls만으로 실행할 수 있을까? $PATH때문!
        - $PATH
            - `echo $PATH`를 통해서 확인해보면, 각각의 경로가 지정되어 있는 것을 알 수 있다.(:으로 구분)
            - Unix계열의 운영체제에는 이 값을 기본적으로 가지고 있다.
            - 만약 ls라는 명령어를 실행하면, $PATH라는 변수에 담긴 디렉토리들을 검색하여 그 디렉토리에 ls라는 실행파일이 존재하는곳을 차례대로 뒤진다.
            - 그 뒤진 디렉토리에서 ls라는 파일이 발견되면 그것을 실행할 수 있는 것이다.
            - $PATH는 변경가능하며 특정 디렉토리를 추가하면 그 디렉토리에 있는 파일도 바로 실행가능하다.
            - 이런 변수를 환경변수라고 부른다.
        - whereis --help 혹은 man을 통해 option을 확인할 수 있다.
### 11. background 실행
- 멀티태스킹
    - 여러 작업을 하나의 화면에서 가능하다.
    - 윈도우즈에서도 alt + tab을 통해 foreground / background 수행을 변경하였듯이 유닉스 계열에서도 이가 가능하다.
- background실행
    - 우선 nano를 통해 editor를 켜고 아무 내용이나 입력 후 ctrl + o로 저장을 하자.(c9환경에서는 ctrl+shift+alt+o)
    - 그런 다음 ctrl + z를 누르면(c9은 ctrl+shift+alt+z) 프로그램에서 나가진 것처럼 보여진다.
    - ls를 해보면 해당 파일이 생성되었을 것이다.
    - fg(foreground)를 입력하면? 아까 작업하던 프로그램이 다시 켜진다.
    - 다시 대충 수정 후 ctrl+z를 하면 다시 프로그램이 background로 이동한다.
    - cat으로 파일내용을 확인해보면 해당 파일이 저장되어 있음을 알 수 있다.
    - 이 때, `jobs`을 실행하자. 그러면 nano프로그램이 bg에서 실행되고 있다는 것을 확인할 수 있다.
    - 이 때, vim을 켜서 다른 editor를 켜보자.
    - 다시 ctrl+z로 보내면 nano와 vim이 bg에 있을 것이다.(jobs로 확인)
    - 다시 nano를 하나 더 켜고 ctrl+z하면 또 그것도 background에서 확인가능하다.
    - fg를 해당 상황에서 수행해보면 가장 마지막에 bg로 보낸 것이 fg로 이동한다.
    - 만약 특정 프로그램을 실행하고 싶으면 jobs를 통해 숫자를 확인하여 수행한다. ex) `fg %2`
    - 특정 프로그램을 그 때 종료하고 싶으면 `kill %2`와 같이 한다.
    - `kill -9 %2`를 하면 강제종료. -9없으면 일반적 종료
- &
    - `ls -R / > result.txt 2> error.log` : 이는 지정 디렉토리의 모든 하위 내용을 표시하는 것. 그를 저장
    - 수행하면 일부는 정상적으로 작동했을 것이며, permission denied등 오류가 난 것은 error.log에 있을 것이다.
    - 해당 내용도 시간이 걸리지만, ls -alR로 하면 더 시간이 오래 걸릴 것이다.
    - 따라서, 해당 명령의 끝에 &를 하면 background에서 작업이 수행될 것이다. 그 상태에서 jobs를 해보면 bg에서 수행되고 있다는 것을 알 수 있다.
    - 작업이 끝났을 때는 jobs를 해보면 해당 running 중이던 프로세스는 더이상 없을 것이다.
### 12. Daemon
- 지금까지 사용한 프로그램
    - ls, mkdir, rm
    - 위와 같은 프로그램은 항상 실행되는 프로그램이 아니다. 즉, 데몬이 아니다.
- 데몬?
     - 항상 실행되는 특징이 있다.
     - 냉장고 vs Tv를 생각해보자. 냉장고는 항상 켜져 있고, 항상 작동한다. Tv는 그렇지 않다.
     - 냉장고 같은 경우는 언제 사용될지 알 수 없기 때문에 항상 켜져 있어야 한다. 
     - server 와 같은 프로그램은 daemon에 해당한다.
- 웹 서버
    - apache 서버로 시도해보자.
    - `sudo apt-get install apache2`
    - 해당 프로그램은 daemon 프로그램이 위치하는 디렉토리인 `/etc/init.d`에 위치한다.
    - apache2와 같은 프로그램은 시작할 때 `sudo service apache2 start`와 같이 실행해야 한다.
    - 멈출 때는 `sudo service apache2 stop`이다.
    - daemon program은 start, stop으로 켜고 끌 수 있다.
    - 또한, 해당 서버는 컴퓨터가 켜지면 자동으로 켜질 필요가 있다.
    - /etc/rc3.d 로 이동한다. (rc3.d는 cli 구동중일 경우, gui일 경우에는 rc5.d)
    - 해당 위치에서 ls -l을 해보면 S91apache2 과 같은 링크로 해당 프로그램의 위치가 지정되어 있을 것이다.
    - console로 실행시 자동으로 booting 될 것을 원한다면 rc3.d에 link를 걸면 된다. 
    - S로 시작하는 것은 start되는 것이며, 뒤의 숫자는 우선순위, K로 시작하면 Kill이라서 시작되지 않는다.
### 13. CRON
- CRON
    - 정기적으로 실행되는 작업
    - terminal에서 `crontab -e`라고 하면 원하는 editor를 설정하라고 나온다.
    - 선택한 다음, 해당 editor에 내용을 적으면 그 적은 순서대로 cron이 동작하여 프로그램이 실행된다.
    - 시간 설정
        - `*/1` : 1분에 한 번을 의미. `*/10` : 10분에 한번. 만약 10 1 이면 1시 10분에 실행
        - dom : month 중 특정 day. 24라고 적으면 매달 24일을 의미한다.
        - mon : 월을 지정
        - dow : 요일 지정(0 ~ 6이며 0이 sunday)
        - 따라서, `*/1 * * * * command` : 1분에 한 번씩 command에 지정된 명령을 수행한다.
        - 해당 line에서 *만 쓰면 시간에 상관없이라는 의미이다.
        - 예시
            - 만약 date명령을 통해서 특정 log파일에 date 정보를 계속 추가하고 싶다고 가정하자.
            - `date > date.log`
            - crontab에서는 `*/1 * * * * date >> date.log` 로 하면 1분 마다 date.log에 내용이 추가될 것이다.
            - 해당 내용을 저장 후 `crontab -l`을 수행하면 저장한 내용을 출력해준다.
            - 이제, `tail -f date.log`를 사용하면 해당 명령에 의해 항목이 자동으로 추가될 때마다 refresh될 것이다.
            - 혹시나 에러가 날 수 있으니까 crontab에 아래와 같이 정정하는 것이 좋다.
                - `*/1 * * * * date >> date.log 2>&1` : 즉, 표준 error를 표준 출력으로 redirection시키는 것이다.
                - `&1`이라고 하는 이유는 1이라고만 하면 1이라는 파일에 저장되기 때문이다.
            - C9환경은 cron job을 실행하기 위해서는 premium plan을 이용하고 ssh접속을 해야 한다고 나와있다.
    - 가능한 예시
        - 만약, 사용자가 우리 서버에 특정 정보를 보낸다고 가정했을 때, 우리 서버는 해당 내용이 전달되면 관련 내용을 100000명의 사용자에게 email 발송한다고 가정하자.
        - 그런 경우, mail을 보내는 작업은 시간이 걸리기 때문에 사용자 측에서는 간단한 정보만 보냈음에도 그 작업이 완료될 때까지 대기를 해야하는 비효율이 있을 수 있다.
        - 이런 경우를 방지하기 위해서, 우리 서버는 정보가 전달되면 해당 내용을 따로 저장한 다음, 바로 작업을 종료시켜준다.
        - 그리고, cron을 이용해서 저장된 내용이 추가된 경우 mail을 보내는 작업을 bg에서 수행할 수 있을 것이다.
### 14. Startup script
- Shell의 startup 설정
    - 접속시에 쉘에서 특정 명령이 바로 실행되도록 하는 것.
    - 예시
        - alias l='ls -al'이 있다고 해보자. l만 사용해도 바로 ls -al을 실행할 수 있다.
        - 이 기능을 이용해 자주 쓰는 명령을 좀 더 항상 편하게 쓰고 싶다고 가정하자
        - `echo $SHELL` : 사용하는 shell을 알려준다. 아마 bash일 것인데, bash는 사용자가 bash를 처음 실행시 어떤 특정한 이름의 파일을 실행하도록 설정되어 있다.
        - 그래서 그 파일을 수정하면 되는데 home directory에서 .bashrc를 수정하면 된다.
        - `nano .bashrc`를 통해 마지막에 `echo 'Hi, bash'`를 해보자.
        - bash를 해보면 해당 내용이 출력되는 것을 알 수 있다.
        - 그래서 .bashrc에 코드를 작성하면 쉘이 시작되었을 때 그 영향을 받아 바로 수행된다.
### 15. 다중사용자 시스템
- 다중사용자
    - 유닉스 계열의 운영체제는 다중사용자 기능이 구현되어 있다.
    - 매우 복잡도가 높아지며, 이에 의해 사용자도 배워야할 것이 많아짐.
- 명령어
    - id
        - 접속한 나의 정보를 확인
        - uid : 나의 id
        - gid : 내가 속한 group id
    - who
        - 현재 시스템에 접속한 유저를 확인할 수 있다.
        - ssh를 이용해 원격접속을 하면 who를 통해 접속자를 알아낼 수 있다.
        - exit를 해서 빠져나가면 who로 더이상 확인할 수 없다.
### 16. 관리자, 일반사용자
- 관리자(super user, root user)
    - 지금까지 권한을 얻기 위해서 `sudo`즉, super user의 do를 이용하였다.
    - 그러나, 이는 아무나 할 수는 없는 것이다.(root유저가 될 수 있으나 평시에 일반 권한으로 사용하는 자만 가능)
    - 일반적으로 super user는 root라는 이름을 가진다. 또한 command의 line에서 $가 아닌 #이 된다.
    - 슈퍼 유저가 되는 법
        - `su -` : su는 substitute user로 유저를 바꾸는 것이다. su - root라고 해도 된다.
        - 빠져나갈 때는 exit. logout된다.
    - `sudo passwd -u root` : root유저의 passwd를 unlock할 수 있다.
    - `sudo passwd -l root` : lock을 거는 것이다. 이 때는 root유저가 될 수 없다.
    - `sudo passwd root` : root유저의 비밀번호를 변경할 수 있다.
    - root 사용자의 home directory는 /root이다.(일반 사용자는 접근 불가)
- 일반사용자
    - super user의 권한이 없는 유저이다.
    - 일반사용자 중에서 sudo를 사용할 수 있는 유저는 제한되어 있다.
    - sudo 권한이 있는 유저는 root접속시 `sudo su`를 통해 비밀번호 없이 접속가능하다.
### 17. 사용자추가
- 일반 사용자가 다른 일반사용자를 추가할 수 없다. sudo해야함
- <a href="https://www.cyberciti.biz/faq/unix-create-user-account/">참조</a>
- 추가
    - `sudo useradd -m [user_name]` : user_name에 해당하는 user를 추가한다.
    - 이 때, /home에서 ls해보면 사용자가 추가된 것을 알 수 있다.
    - `sudo passwd [user_name]`을 통해서 비밀번호를 설정할 수 있다.
    - 현재 새로 추가한 user는 sudo의 권한이 없다.
    - sudo 권한을 주기 위해서는 `sudo usermod -a -G sudo [user_name]`과 같이 하면 된다.
        > a는 append이며 -G는 Group에 추가한다는 것이다. 즉, sudo Group에 추가하는 것.

    - 혹은, 애초에 만들 때 sudo 권한이 있도록 만든다. (`sudo adduser [user_name] sudo`)
### 18. Permission
- 사용자가 file 및 directory에 대해 read/write/execute할 수 있도록 혹은 없도록 할 수 있다.
- 권한
    - `ls -l`을 해보면 각 파일의 자세한 내용이 나온다. 아래와 같다.
        > `-rw-rw-r-- 1 user user 0 Dec 4 23:19 aaa.txt`

    - 맨 좌측의 -는 type을 의미한다.
    - 그 뒤 1 전까지는 access mode
        - 여기서 rw-는 owner의 권한, 그 뒤 rw-는 group의 권한, r-- 는 이외 사용자(other)의 권한
        - r은 read, w 는 wrtie, x는 execute
    - 1 뒤의 user는 owner이며 그 뒤 user는 group
- 예시
    - terminal을 여러개 켠다.
    - 각 터미널 유저를 다르게 설정한다.
    - a 유저가 본인의 home directory에서 특정 파일을 만들면, 그룹에 해당하지 않는 일반사용자는 쓰거나 실행할 수 없을것이다.
    - 그 때, b유저가 해당 home directory에 접속하여 write를 하려고 하면 permission denied된다.
- 권한을 변경하는 방법
    - chmod라는 명령어를 사용한다. : change mode
    - 사용 예시 : `chmod o+r [file]`
        - 즉, 중간에는 사용권한에 대한 명시를 할 수 있다.
        - +는 권한을 추가한다는 것이며, r은 권한을 의미한다. -는 당연히 권한을 없앤다는 것.
        - o는 other사용자를 의미하며, u는 owner로 소유자를 의미한다.
- 실행권한(execute)
    - hi-machine.sh를 만들고 내부에 echo를 통해 내용을 추가해보자
    - 현재는 권한이 없으므로 실행이 불가하다.
    - 그러나 `/bin/bash hi-machine.sh`로 하면 실행이 가능하다.
    - 실행권한을 위해서는 `chmod u+x hi-machine.sh`
- 디렉토리의 권한
    - 파일과 다르게 읽기 쓰기 실행이 불분명하다.
    - read권한을 없애면 해당 디렉토리에 소속된 파일의 정보를 열람할 수 없다.
    - write권한이 사라지면, 해당 디렉토리에 새로운 파일 혹은 directory를 만들 수 없다. 물론 rm, mv도 불가
    - x권한은 cd명령으로 진입 가능하냐 불가하냐와 관련된 권한이다.
    - 디렉토리의 depth가 깊은 경우 그 아래의 모든 디렉토리의 권한을 바꾸고 싶다면 -R이라는 옵션을 주면 된다.
        - `chmod -R o+w [directory_name]`
- chmod 명령어
    - mode 변경시에 octal이라는 8진수를 이용해 지정할 수도 있다.
        - `chmod 111 [file_name]` : 해당 파일의 권하을 xxx로만 바꾼다.
        - 110이면 other사용자는 어떤 권한도 없다
        - r은 4, w는 2, x는 1이므로 이 숫자를 조합하면 된다.
    - 대상 지정시 u, g, o로 지정 가능
        - u는 owner, g는 group, o는 other, a는 모든 사용자
        - +는 권한 추가, -는 권한 삭제, =는 지정
            - `chmod a=r [file_name]` : 모든 사용자에게 read권한만 준다.
    - <a href="https://en.wikipedia.org/wiki/Chmod">참조</a>
### 19. GROUP
- group에 대한 권한
    - 특정 user, other도 아니고 group으로 사용자들을 묶어 이름을 주고 파일에 대한 권한을 부여할 수 있다.
    - groupadd라는 명령어로 그룹을 추가할 수 있다.
        - `groupadd [option] [group_name]`로 사용
        - /etc/group이라는 파일에서 group에 대한 정보를 확인할 수 있다.
        - group을 추가했으면 user를 추가한다.
    - usermod
        - 사용자 account를 수정하는 명령어
        - 그룹에 사용자를 추가하기 위해서는 다음과 같은 명령어를 쓴다.
        - `sudo usermod -a -G [groupname] [username]` 
    - chown
        - file의 owner와 group을 바꾼다.
        - `sudo chown [user_name]:[group_name]` : 유저 및 그룹을 바꾼다.
### 20. 인터넷, 네트워크, 서버
- 요청/응답
    - 유저가 자신의 컴퓨터에서 `google.com`이라고 브라우저에 치면, request를 하는 것.
        - 이러한 google.com이라고 하는 것이 *domain name*
        - terminal에 `ping google.com`을 해보면 숫자 4개가 나올 것이다. 이것이 ip주소
        - 도메인과 ip주소??
            - 도메인을 통해서 주소해 입력을 하면, request가 그로 인해 되는 것이 아니라, ip address로 변환되어 그로 접속해 요청을 하는 것이ㅏㄷ.
            - 어떻게 ip address를 찾을 수 있는가? 그것은, DNS라는 서버에 의한다.
            - DNS 서버는 모든 domain의 각각의 ip address를 알고 있는 거대한 저장고라고 보면 된다.
            - 그래서 DNS에 접속해 ip를 찾아낸 다음, 그 ip주소로 요청을 하게 되는 것이다.
    - google의 server에 요청이 가고 해당 server는 client computer로 response를 보낸다
- 나의 ip주소
    - terminal에 ip addr이라고 쳐보면 아래 쪽에 inet뒤에 4개의 숫자가 있을 것이다.
    - 그것이 나의 컴퓨터의 ip address
    - 혹은 ipinfo.io/ip라고 주소에 쳐보면 된다.
    - 이를 나의 cli환경에서 보고 싶은 경우 : `curl ipinfo.io/ip`로 해본다.
        - 그런데 ip addr은 나의 실제 ip를 의미하며
        - curl로 보는 것은 내가 온라인으로 접속시에 어떤 ip로 접속하게 되는지를 보여준다.
        - 대부분의 경우에 이 두가지가 다르다. 왜냐?
            - 일반적으로 가정에서 사용시에, internet을 사용하는 여러가지의 기기가 있을 것이다.
            - 이 경우에 각각의 기기마다 다른 ip를 부여하면 좋겠지만, 이러면 .. 비쌈 ㅠㅠ
            - 따라서, 그 사이에 어떤 장치를 붙인다. 그것이 공유기!
            - Router라고 부르는 장치인데, 각 기기를 여기에 붙이는 것이다.
            - 이러면, 통신사와 하나의 회선을 계약하여 사용할 수 있게 되는 것이다.
            - 근데, 공유해서 쓰는 ip는 router의 ip이고, 각 기기도 무조건 ip가 있어야 통신이 가능하다.
            - 공유하는 ip는 외부에 공개되는 ip로 public address이다.
            - 사설 ip라는 개념을 이해해야 한다.
        - 사설 ip
            - 외부에 공개되지 않고, 자체적으로 사용하지는 않는 private address이다.
            - 각 기기마다 부여되는 ip이며, 10.0.3.1 , 10.0.3.2 와 같이 각 기기에 부여된다.
        - 그래서 curl로 접속하면 router의 주소로 접속하는 것이므로 외부에서는 그 주소로 접속했다고 판단한다.
        - ip addr이라는 명령은 각 기기에 실질적으로 어떤 ip가 있는지를 나타내기 때문에 private ip가 되는 것이다.
        - 그래서, 이 두가지가 같으면 해당 기기를 바로 server로써 사용할 수 있지만 아니라면 사용할 수 없다.
- 다른 컴퓨터로 연결하는 방법
    - 같은 공유기를 사용하는 기기들은 서로간에 통신이 가능하다.
    - 그리고 라우터를 설정함에 따라 공용 ip를 통해 특정 기기에 접속하는 것도 가능하다.
    - 이외의 방법도 존재
### 21. 웹서버(아파치)
- 설치
    - `sudo apt-get install apache2`
    - 무엇으로 설치해야 할지 모르겠으면 검색하거나, `sudo apt-cache search apache`해본다.
- 시작
    - `sudo service apache2 start`
    - `sudo service apache2 restart`
- 정지
    - `sudo service apache2 stop`
- shell에서 직접 접속하기(웹 브라우징)
    - `sudo apt-get install elinks` : elinks를 설치하고 실행
    - elinks -> 바로 웹 브라우저에서 하듯이 접속하여 활동할 수 있다.
    - `elinks http://[ip_address]/`
- localhost로 접속하기
    - 자기 자신의 컴퓨터에 설치된 서버에 접속하는 경우
    - 127.0.0.1과 localhost는 같은 것.(자기 자신을 가리키는 ip이다)
    - `elinks 127.0.0.1`로도 자신의 컴퓨터의 서버에 접속할 수 있다.
    - 혹은 `elinks http://localhost`로도 가능
- 웹서버 configuration
    - /etc에는 다양한 설정파일이 존재함.
    - /etc/apache2/conf에 보면 다양한 설정내용이 있을 것이다.
    - 해당 내용의 아래쪽에 보면 `IncludeOptional sites-enabled/*.conf`와 같이 되어 잇다.(버전마다 다를 수 있다.)
    - 그 내용은 해당 디렉토리의 .conf라는 파일을 모두 읽어서 사용한다는 것.
    - 해당 디렉토리에 가보면 000-default.conf로 link가 걸려있을 것이다.
    - 해당 파일을 열어보면 `DocumentRoot /var/www/html`이라고 되어 있는데, 그 디렉토리에 들어가보면
    - 기본적으로 index.html파일이 존재할 것이다. 그 파일의 이름을 바꾸고 `elinks http://127.0.0.1/index.html`을 해보면 찾을 수 없다고 할 것이다.
    - 다시 index.html파일을 만들어 접속해보면 동작할 것이다.
    - 즉!, /etc/apache2의 여러 설정을 참고하여 사용자의 접속이 들어오면 storage안에 있는 어디에서 파일을 뒤질 것인가를 알아내고 response를 보내는 것이다.
    - 이렇게 사용자가 요청한 파일을 찾는 최상위 디렉토리가 document root이다.(/var/www/html)
- log
    - 000-default.conf에 중간에 보면 error.log, access.log파일에 error, customlog파일이 있을 것이다.
    - 해당 파일들은 /var/log/apach2에 존재한다.
    - 해당 내용 중 access.log는 웹서버에 접속할 때마다 로그가 추가된다.
    - 따라서, 해당 로그를 통해서 다양한 정보를 얻을 수 있고 이를 통해 대부분의 문제를 해결할 수 있다.
### 22. SSH(매우 중요)
- SSH?
    - 원격제어를 할 경우에 사용된다.
    - 오늘 날, 리눅스 시스템을 데스크탑 대용으로 쓰는 경우는 많지 않다.
    - shell을 통해서 서버를 제어하는 것.
    - 이를 위해선 client-server구조가 필요하다.
    - SSH Client - SSH Server가 상호 작용.
    - SSH Client에서 rm, ls, pwd와 같은 명령어를 입력하면 자신의 컴퓨터를 제어하는 것이 아니라, SSH Server에 전달되고 그 Server는 자신의 컴퓨터에 동작시키고 그 결과를 받아 Client에 표시한다.
- 설치
    - `sudo apt-get install openssh-server openssh-client`
    - `sudo service ssh start`
    - `sudo ps aux | grep ssh`
- 접속
    - 현재, 컴퓨터는 SSH SERVER가 설치된 상태이고 해당 서버는 계속 실행되다가 Client의 접속을 기다린다.
    - ip addr을 해서 현재 SERVER가 설치된 컴퓨터의 ip address를 알아본다.
    - `ssh [user_name]@[ip_address]` : 이를 통해 원격 접속이 가능하다.
    - 이제 이 상태에서는 Client가 있는 컴퓨터에서는 원격으로 접속하였으므로 명령을 내리면 본인 컴퓨터가 아닌 원격 컴퓨터를 제어하는 것이 된다.
### 22. 포트
- 포트
    - www.naver.com은 그냥도 가능하지만 www.naver.com:80으로도 접속된다.
    - 하지만 다른 것으로는 안된다. 그것이 포트, web은 80번 포트를 쓴다.
    - SSH접속시 `ssh -p [port_num] [ip_address]`로 접속할 수 있다.
    - ssh일 때는 22로 입력하면 접속된다. ssh는 22번 포트를 사용하기 때문이다.
    - 포트는 구멍이라고 생각하자. 0~65xxx번 까지 존재한다.
        - ssh는 22번으로 연결되도록 약속되어 있으며, webserver는 80번으로 약속되어 있다!
        - 그래서 웹 브라우저로 서버에 접속시에 주소에 :80을 추가하지 않더라도 알아서 80번 port를 찾아가서 서버에 접속한다.
    - ssh의 경우 /etc/ssh/sshd_config에 보면 port 22라고 적혀있으니 해당 번호를 바꿀 수 있다.
    - 그 번호를 바꾸고 ssh restart를 하면 바꾼 설정이 반영된다.
    - 이제는 기존 방식으로는 접속이 안된다. -p 2222로 접속해야 한다.
    - 이 포트번호를 변경함으로써 사용자가 다른 포트번호로 접속하도록 만들 수 있다.
- 포트 포워딩(port forwarding)
    - ISP(인터넷 서비스 공급자)와 계약하여 한 가정이 여러 기기를 인터넷에 접속하는 데, 이 때 대부분 router를 사용할 것이다.
    - 그러면, 이 공유기(라우터)를 이용하여 케이블로 연결하거나, 무선으로 연결하여 하나의 회선을 사용한다.
    - 이 때, ISP에서 제공하는 public ip address가 있는데, 이것이 한 예로 *211.46.24.37*이라고 가정하면, 이 ip는 router의 ip가 된다.
    - 각각의 공유기를 이용하는 기기는 192.168.0.2 / 0.3 / 0.4와 같은 ip를 부여받는다고 하자.(private ip address)
    - 이 때, 외부의 다른 유저는 공유기 ip를 알면 접속이 가능하지만, 사설 ip로는 접속할 수는 없다. 기본적으로는
    - 그렇다면, 어떻게 접근할 수 있도록 할까? 그것이 포트 포워딩을 통해 가능하다.
- 포트포워딩의 이란?
    - router에도 당연히 port가 존재하며, 사설 ip로 연결된 컴퓨터에 서버가 있으면 당연히 port가 있다.
    - 그러면, router로 특정포트로 누군가 접속하면, 그 접속을 어떠한 특정한 computer로 전달한다. 이것이 포트 포워딩
    - 예를 들어, 사용자가 9000번 포트로 router에 접근했다면, router의 설정을 열어서 9000 ---> 192.168.0.4:80으로 설정을 지정하는 것이다.
    - 공유기마다 환경설정 방법은 다르다. 직접 알아봐야 함.
    - 이와 같이 공유기 안쪽에서만 통용되는 ip를 default gateway라고 부른다.(공유기는 관문과 같은 역할이라고 보면 된다.)
- default gateway
    - 공유기의 제조사마다 다른데 해당 gateway ip를 통해 브라우저에 접속하면 공유기 설정이 가능한 곳으로 접속된다.
    - 관리도구 - 고급설정 - NAT라우터설정 - 포트포워드 설정에서 설정가능
    - 내부 IP주소는 서버를 설치할 컴퓨터의 내부의 computer를 의미한다. 규칙이름은 원하는대로 하고, 외부 포트에는 route로 접근할 포트의 번호를 지정하는 것(범위 가능), 내부 포트는 서버가 설치된 컴퓨터의 포트를 의미한다.
    - 해당 내용에서 포트포워딩 실습이 가능. 강의 참조
    - <a href="https://opentutorials.org/course/2598/14470">참조</a>
### 24. domain
- hosts파일
    - 만약 google.com으로 접속하면 /etc/hosts를 먼저 살피고 그거를 접속하고, 만약 존재하면, DNS에는 접속하지 않는다.
    - 그래서 /etc/hosts라는 파일은 host들의 ip를 적어놓는 파일이다. 즉, host들의 name을 ip로 적어놓는것.
    - 예전에는 이것을 거의 썼지만, 지금은 host가 너무 거대해졌기 때문에 그를 본질적으로 해결하기 위해 DNS를 사용하는 것이다.
    - 일시적으로 특정 domain의 ip를 변조해서 써야할 경우가 있을 때 매우 편리하다. 이때문에 크래커들의 공격대상이 된다.
    - 
- DNS
    - Domain Name Server
    - cat /etc/resolv.conf 를 해보면, nameserver가 여러개 있을 것이다.
    - 이것이 ISP의 DNS서버임. 여러개 있는 이유는 부하분산, 백업을 위해
    - 이제 우리 서버에 접속하게 하기 위해서는 이 DNS에 우리 ip를 지정해야 하는데, 그를 위해서는 domain을 구입해야 한다.
    - 무료를 원하면 google에 free domain을 검색하자
    - 구매를 한 다음, 사용하고 싶은 IP주소를(curl ipinfo.io/ip의 퍼블릭으로 해야함), domain name에 setting시킨다.(DNS서버들은 이제 나의 domain이 어떤 ip인지 알게 됨)
    - host [my_domain] : 이를 해보면 DNS서버가 이제 인식하고 있는지를 확인할 수 있다.(시간이 걸림)
- 서브 도메인
    - 여러 개의 서버가 있을 때, 각각의 domain을 사야 할까? 가격이 부담된다.
    - 그래서 기존의 domain을 이용해 여러번 사용할 수 있도록 지정할 수 있다.
    - 이것이 서브 도메인인데 DNS management를 해주는 사이트에서
    - add record를 통해서 이름을 blog.[my_domain], site.[my_domain]과 같이 지정하여 서로 다른 ip에 여러가지 서브 도메인을 줄 수가 있다.
- DNS의 원리
    - `dig +trace [domain_name]` : 특정 도메인을 의뢰하여 ip를 알아내는데, 여러 가지 서버를 거쳐서 알아내는 과정을 보여줌
    - 도메인은 엄청 많고 계속해서 늘어날 것인데, 한 대의 서버에서 그것을 모두 설계하기에는 너무 위험하다.
    - 그래서, 해당 문제를 예방하기 위해 여러 서버에 분산하여 설계하였다.
    - 따라서, dig +trace를 command로 명령했을 때, 나오는 root-servers.net부분이 root dns list이다.
    - 그래서, 우리가 요청을 하면 우리서버의 ip를 찾는 dns서버는 .com, .me, .net등을 담당하는 서버를 root dns server에 물어본다.
    - 그러면, root dns server에서는 그 결과를 찾아 돌려주는데, .com이면 그 서버를 찾아서 돌려주는 것이다. 그것은 대략 4대로 부하분산 되어 있다.
    - 이제 .com의 dns 서버에게 우리 도메인의dns 서버를 물어보게 되고 그 서버를 받을 수 있으며 또 그 서버에게 우리의 ip를 얻어낼 수 있다.
    - 즉, ip address가 나올 때까지 계속해서 물어보는 것이다.
### 25. 서버간 동기화(rsync)
- 구글 드라이브, 드랍박스와 같이 2개의 컴퓨터가 있을 때 특정 컴퓨터의 내용을 다른 한쪽에 올려서 한쪽의 변경사항이 다른 쪽에 반영되는 것이 rsync
- r은 remote의 약자이다. 즉, 원격으로 떨어진 컴퓨터 사이에서 네트웤을 통한 sync를 하는 것을 말한다.
- 실습
    - rsync라는 디렉토리를 만들고 dest, src라는 디렉토리를 내부에 만든다.
    - 이제, src에서 파일을 만들고 dest에 sync시키는 작업을 진행하자
    - src에서 `touch test{1..10}을 만들면 10개의 파일이 자동으로 생성될 것이다.
    - 이제 상위 디렉토리에서 dest로 동기화 `rsync -a src dest` : 근데 이러면 src자체가 이동함
    - src디렉토리의 내부에 있는 것을 옮기길 원하므로 `rsync -a src/ dest`로 해야한다.
    - `rsync -av src/ dest`로 하면 자세한 내용을 알려주며 싱크를 맞춘다.
    - 만약, 복사된 내용에서 특정 파일을 삭제하고 다시 rsync를 하면 삭제된 파일만 들어간다.
    - 변경사항이 있는 경우에만 내용을 전달함!
    - `-a`는 archive mode로써 특정 디렉토리를 지정했을 때, 해당 디렉토리를 전체 복사하며, 변경사항(권한 등)만 내용을 전달하는 기능이다.
- rsync 실습2
    - 다른 컴퓨터로 이번엔 sync를 시켜보자
    - 이를 위해서는 ip addr을 통해서 sync시킬 컴퓨터의 ip를 알아야 한다.
    - `rsync -azP ~/rsync/src/ [user_name]@[ip_address]:[directory]` : 다른 컴퓨터의 사용자의 ip에 맞게 지정해 특정 디렉토리로 rsync를 하는 것이다.
    - z는 압축이며, P는 전송되는 상황을 progress bar로 보여준다.
### 26. ssh공개키
- 로그인 없이 로그인하기
    - 두 대의 linux환경을 준비하자
    - 우선 ssh공개키, 개인키를 만들어야 한다. : `ssh-keygen`
    - 만들면, *~/.ssh/id_rsa*의 파일의 형태로 내용이 저장된다.(비밀번호 안해도 됨)
    - .ssh로 가보면 id_rsa, id_ras.pub으로 두 개의 파일이 중요하다.
    - 전자는 private key이며, 후자는 public key이다.(private key는 절대 노출되어선 안된다.)
    - 이 때, 공개키가 저장되어 있는 컴퓨터에 로그인 없이 접속이 가능해진다.
    - `authorized keys`라는 내용의 파일도 있는데 이 내용에, public key 내용을 복사해서 끝에 붙여주면 된다.
    - `ssh-copy-id [user_name]@[ip_address]`를 하면 로그인을 시도하고자 하는 컴퓨터의 authorized keys파일의 끝에 퍼블릭 키가 추가된다.
    - 이 때, 공개키를 만든 컴퓨터에서 다른 로그인하고자 하는 컴퓨터에 바로 접속이 가능해진다.(공개키가 추가되었기 때문)
    - 접속시에는 `ssh [user_name]@[ip_address]`를 통해 접속된다.
- rsync동기화
    - `rsync -avz . [user_name]@[ip_address]:[directory]`
    - 현재 디렉토리의 내용을 다른 컴퓨터에 바로 sync가 가능하다.
    - 이를 수행할 때, 비밀번호가 없이 되는 이유는, ssh공개키를 통해 인증이 되었기 때문이다.
    - 이 과정을 자동으로 하기 위해서 cron을 이용하면 정기적으로 backup을 자동화처리할 수 있다.
- RSA
    - 암호화기법이다.
        - 정보를 필요한 사람만 알 수 있도록 이해할 수 없는 형태로 변경가능한데 이것이 encrypt, 즉 암호화이다.
        - 해당 내용을 원래 상태로 돌리는 것을 decrypt, 즉 복호화이다.
        - 그래서 key를 이용하여 암호화를 하고 복호화를 할 수 있다.
        - 만약 이 과정에서 같은 key를 쓰면 대칭적 방식!
        - 암호화를 private key, 복호화를 public key를 써서 하면 비대칭방식 : 이 대표주자가 RSA!
    - RSA방식
        - SSH client가 SSH server에 접속하게 되면, 서버는 random하게 생성한 key를 client에게 준다.
        - client program은 .ssh라는 directory에서 id_rsa를 찾아서 random key를 암호화한다.
        - 다시 SSH server에 암호화된 내용을 보내주게 되고, server에서는 authorized keys에 저장된 공개키를 통해 복호화한다.
        - 복호화된 결과가 자신이 처음 전송했던 random key와 같다면!, ssh client가 권한이 있는 유저임을 확신할 수 있다.
        - 그래서 로그인을 안전하게 할 수 있는 것이다.
### 추가
- ; - 앞의 명령어가 실패해도 다음 명령어가 실행(앞의 명령어의 성공여부 무관)
- && - 앞의 명령어가 성공했을 때 다음 명령어가 실행(앞의 명령어 성공이 반드시 수반돼야)
- & - 앞의 명령어를 백그라운드로 돌리고 동시에 뒤의 명령어를 실행
    - 그래서 `mkdir test & cd test`에서 cd는 동작되지 않는다. 동시에 수행하려고 하기 때문.
- 명령의 그룹핑 : {}
    - `mkdir test3 && { cd test3; touch abc; echo 'success!!' } || echo 'There is no dir';`
    - mkdir test가 성공했을 때 cd test2; touch abc를 실행하고 success!!를 출력합니다.  실패했을 때 echo 'There is no dir'를 실행합니다.  이때 실행되는 명령들은 현재 쉘의 컨텍스트에서 실행됩니다. 만약 서브 컨텍스트에서 실행하고 싶다면 '('와 ')'를 사용하시면 됩니다. (참고)